# -*- coding: utf-8 -*-
"""cnn.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zBHzqY8Nb7a66LhT8We4zPI-828Kuh3O
"""

import torch
import torchvision
import torch.nn as nn
import numpy as np
import pandas as pd

class network(nn.Module):
    def __init__(self):
        super(network,self).__init__()
        # self.quant = torch.quantization.QuantStub()
        self.conv1 = nn.Conv2d(2, 100, (39,1),1)
        self.relu1 = nn.ReLU()
        self.conv2 = nn.Conv2d(100,100 , (1,1),1)
        self.relu2 = nn.ReLU()
        self.fc1 = nn.Sequential(
            nn.Dropout(0.5),
            nn.Linear(400, 400)
        )
        self.fc2 = nn.Linear(400, 2)
        # self.dequant = torch.quantization.DeQuantStub()

    def forward(self,x):
        # x = self.quant(x)
        x = self.conv1(x)

        x = self.relu1(x)
        x = self.conv2(x)

        x = self.relu2(x)
        x = x.reshape(-1,400)
        x = self.fc1(x)
        x = self.fc2(x)
        # x = self.dequant(x)

        return x

device = 'cpu'
model = network()
learning_rate = 0.001
criterion = nn.MSELoss()
optimizer = torch.optim.Adam(model.parameters(),lr = learning_rate)
model = model.to(device)
model.load_state_dict(torch.load('/content/quantized.pt',map_location=torch.device('cpu')))
mae = nn.L1Loss()
model.eval();

array = torch.from_numpy(np.load("/content/totestFID3994.npy"))

single_sample_tensor = torch.tensor(array, dtype=torch.float32).to(device)

with torch.no_grad():
    output = model(single_sample_tensor)


print(output)

